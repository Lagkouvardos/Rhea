#' Script: Statistical comparison of taxonomic composition and alpha-diversity parameters between groups
#' Author: Ilias Lagkouvardos

##################################################################################
######              Short information about the script                      ######
##################################################################################

#' Parameters:
#' Values below a relative abundance threshold of 0.5 % are not taken into account.
#' Taxa with a median relative abundance <1 % in all groups are not considered for statistical analysis.
#' Taxa that are not detectable in at least 30 % of samples in each group are removed.
#' These parameters can be changed by users below in the designated area of the script 

#' Statistics:
#' Friedman Rank Sum Test using Skiwalling method for handling missing values is applied.
#' An extra line is added for samples without complete time information
#' Paired Wilcoxon Signed Rank Test is used for pairwise comparisons (only significant differences are shown in the graphical PDF output).
#' Fischer Test is performed for testing significance of prevalences (only significant differences are shown in the graphical PDF output).
#' P-values are corrected using the Benjamini-Hochberg method.

#' Output:
#' Data as tab-delimited table modified from the input table according to selected abundance and prevalence thresholds.
#' Output tables containing taxa names, p-values, and corrected p-values (for Wilcoxon and Kruskal-Wallis Test separately).
#' Box-, dot-, or violin-plot (as PDF) with corresponding p-value tables.

##################################################################################
######             Set parameters in this section manually                  ######
##################################################################################

#' Please set the directory of the script as the working folder (e.g D:/studyname/NGS-Data/Rhea/beta-diversity/)
#' Note: the path is denoted by forward slash "/"
setwd("D:/path/to/Rhea/5.Serial-Group-Comparisons/")  #<--- CHANGE ACCORDINGLY !!!

#' Please give the file name generated by the Create_Input_Table.R script
input_filename = "overtime-input-table.tab"              #<--- CHANGE ACCORDINGLY !!!

#' The name of the dependent variable that the analysis will be performed on (different time points)
dependant_variable_name <- "TimePoints"

#' Please enter the order of the group names
#' If no group names are writting groups are ordered automatically
group_order=c("")

#' The name of the ID variable that the analysis will be performed on (the id of the subject that was followed overtime)
id_name = "Participant.ID"

#' Please enter the position in the table (column number) where the dependant variable starts (e.g. Richness)
#' Note: the first column containing sample names does not count!
dependant_variables_start <- 3

#' Please enter the position in the table (column number) where relative abundances of OTUs or taxonomic groups start
#' Note: the first column containing sample names does not count!
taxonomic_variables_start <- 6

#' The cutoff of relative abundance; all values below this cutoff will be zeroed (default cutoff is 0.5 %)
abundance_cutoff <- 0.5

#' The prevalence cutoff; at least one group must have a number of samples above the selected treshold
#' for the variable to be tested (default cutoff is 0.3 = 30 % of samples are positive within a given group) 
prevalence_cutoff <- 0.3

#' The minimum median abundance value that must be observed in at least one group before statistical test is performed
max_median_cutoff <- 1

#' Replace 0 Value with NA 
ReplaceZero = "YES"

#' Set the graphical output parameter 
#' 1 = without individual values as dots
#' 2 = with individual values as dots
#' 3 = with individual values as dots and with sample names
PlotOption = 1

#' Set the significance cutoff level (default cutoff is 0.05 but it can be set lower)
sig.cutoff <- 0.05

#' Missing values are removed by default ("NO").
#' If missing values should be replaced by Skillings-Mack method please change this parameter to "YES"
ReplaceMissingValues ="NO"

######                  NO CHANGES ARE NEEDED BELOW THIS LINE               ######

##################################################################################
######                             Main Script                              ######
##################################################################################

# Check if required packages are already installed, and install if missing
packages <-c("plotrix","PerformanceAnalytics","reshape","ggplot2","gridExtra","grid","ggrepel","gtable","Matrix","cowplot","muStat") 

# Function to check whether the package is installed
InsPack <- function(pack)
{
  if ((pack %in% installed.packages()) == FALSE) {
    install.packages(pack)
  } 
}

# Applying the installation on the list of packages
lapply(packages, InsPack)

# Make the libraries 
lib <- lapply(packages, require, character.only = TRUE)

# Check if it was possible to install all required libraries
flag <- all(as.logical(lib))

#####################################################################################################################
####                                        Functions to be used  in main Script.                            ########
#####################################################################################################################

# Function to calculate relative abundance
rel.abundance <- function(data)
{
  total = sum(data)
  rel.data <- 100 * data / total
  return(rel.data)
}

# Replace abundance with zero if value is below given cutoff
abundance.fix <- function(data)
{
  data[data < abundance_cutoff] <- 0
  return(data)
}

# Replace zero value with NA 
fill_zero.NA <- function(data,ReplaceZero)
{
  if (missing(ReplaceZero)) {
    ReplaceZero == "NO"
  }
  if (ReplaceZero == "YES") {
    data[data == 0] <- NA
    return(data)
  }else{
    return(data)
  }
}

# Return maxima and minima values of the given input value
max.fun <- function(data)
{
  data.max <- max(as.numeric(as.character(data)), na.rm = TRUE)
  return (data.max)
}

# Calculate the prevalence of the given input table
pre.fun.na <- function(data)
{
  prevalence <- nnzero(data, na.counted = FALSE)
  return(prevalence)
}

# Return the maximum median value for each group
max.med <- function(data)
{
  max.median <-max(aggregate (data ~ independent_variable,FUN = median,simplify = TRUE)[,2])
  return(max.median)
}

# Return the prevalence ratio
max.pre <- function(data)
{
  
  # Return the number of samples (excluding NA) for each group separately
  found <- aggregate (data ~ independent_variable,FUN = pre.fun.na,simplify = TRUE,na.action = na.pass)[,2]
  
  # Return the total number of samples (including missing values) for each group separately
  all <- aggregate (data ~ independent_variable,FUN = length,simplify = TRUE,na.action = na.pass)[,2]
  
  # Calculate the ratio for each group and return the maximum ratio out of the groups
  max.ratio <- max(found / all)
  return(max.ratio)
}

# Set the theme to change text for plotting (ggplot - Gtable)
mytheme <- gridExtra::ttheme_default(
  
  # Adjust settings for the text inside table
  core = list(fg_params = list(cex = 0.8)),
  
  # Adjust the test for column and row header
  colhead = list(fg_params = list(cex = 0.9)),
  rowhead = list(fg_params = list(cex = 1.0))
)

###################       Read all required input files      ####################

# Load the tab-delimited file containing the values to be analyzed (samples names in the first column)
original_table <- read.table (file = input_filename, check.names = FALSE, header = TRUE, dec = ".", sep = "\t", row.names = 1, comment.char = "")

#####################################################################################################################
####                                      Pre-processing of OTUs Table                                       ########
#####################################################################################################################

# Store repeated time variable columns from original table 
independent_variable = as.factor(original_table[[dependant_variable_name]])

# Check if group_order includes all groups if not the default order will be used
if(dim(as.data.frame(group_order))[1]!=nlevels(independent_variable)) { 
  group_order <- levels(independent_variable)
}
#ifelse(group_order != "", independent_variable <- factor(independent_variable,levels=group_order), independent_variable)
# Store columns with sample ID information from original table 
id_variable = as.factor(original_table[[id_name]])

# Store metadata variable columns from original table 
my_meta_data <- original_table[1:taxonomic_variables_start - 1]

# Store relative abundance values of all OTUs
my_otu_data <- original_table[taxonomic_variables_start:dim(original_table)[2]]

# Transform data by zeroing very low abundances (based on given abundance cutoff - abundance_cutoff)
my_otu_mod =  as.data.frame(apply(my_otu_data,2,abundance.fix))

# Transform data by replacing all zero values with missing values
# Column consisting of "NA" or "0" only are removed (see below)
my_otu_mod_noz = as.data.frame(apply(my_otu_mod,2,fill_zero.NA,ReplaceZero))

# Remove column if entire OTU column contain zeros or missing values
my_otu_mod_noz <- my_otu_mod_noz[,!apply(my_otu_mod_noz , 2 , function(x) all(is.na(x) | (x == 0)))]

# Transform data by removing any OTU with median relative abundance below cutoff
t_otu_mod_noz = as.data.frame(t(my_otu_mod_noz))

# Calculate median for each OTUs
t_otu_mod_noz$max.median <- apply(t_otu_mod_noz,1,max.med)

# Select OTUs above median cutoff (med.cutoff)
selected_max <- t_otu_mod_noz[t_otu_mod_noz$max.median > max_median_cutoff,]

# Remove calculated median column "max.median"
selected_max$max.median <- NULL

# Make a separate object as data frame (columns are OTUs and rows are samples)
otu_mod_noz_max <- as.data.frame(t(selected_max))

# Transpose data (columns are samples and rows are OTUs)
t_otu_mod_noz_max = as.data.frame(t(otu_mod_noz_max))

# Transform data by removing all OTUs with prevalence below the given cutoff
t_otu_mod_noz_max$pre <- apply(t_otu_mod_noz_max,1,max.pre)
selected_pre <- t_otu_mod_noz_max[t_otu_mod_noz_max$pre > prevalence_cutoff,]
selected_pre$pre <- NULL

# Transform and filter OTU table
otu_mod_noz_max_pre <- as.data.frame(t(selected_pre))

# Merge the metadata and OTU data in one table 
# This table will be used as input for the analysis
input_table <- cbind(my_meta_data,otu_mod_noz_max_pre) 

# Check if all time points are available
bool_vec <- table(input_table[[id_name]])==nlevels(as.factor(input_table[,dependant_variable_name]))

# List with IDs without all time points
bool_names <- names(subset(bool_vec,bool_vec==FALSE))

length <- dim(input_table)[1]

for( i in 1:length){
  # Check if time point information is needed for the ID
  if(input_table[i,id_name] %in% bool_names) {
    # Delete ID from the list if time point information was already added
    bool_names <- bool_names[bool_names != input_table[i,id_name]]
    id_sub <- subset(input_table, input_table[,id_name] == input_table[i,id_name])
    # Which timepoints are already available and which time points are missing
    missing <- levels(independent_variable)[which(levels(factor(input_table[[dependant_variable_name]],levels=group_order)) %in% id_sub[,dependant_variable_name]==FALSE)]
    # Add a line with all missing time points for the i-th ID
    for (j in 1:nlevels(as.factor(missing))) {
      # Add a row to to input_table
      input_table <- rbind(input_table,rep(NA,dim(input_table)[2]))
      # Add missing timepoint information
      input_table[dim(input_table)[1],dependant_variable_name] <- missing[j]
      # Assign ID to the missing time point
      input_table[dim(input_table)[1],id_name] <- input_table[i,id_name]
    }
  }
}


# Store repeated time variable columns from original table 
independent_variable = factor(input_table[[dependant_variable_name]],levels=group_order)

# Store columns with sample ID information from original table 
id_variable = as.factor(input_table[[id_name]])

# Convert independent variable into factor to avoid errors
input_table[,dependant_variable_name] <- factor(input_table[,dependant_variable_name],levels=group_order) 


#####################################################################################################################
####                              Differential Statistical Analysis                                        ########
#####################################################################################################################

# The number of total observations per category (independant variable) to be used in the analysis
total <- summary(independent_variable)

# Create vector with group information 
prevalence_list <- as.numeric(independent_variable)

# Create vector with prevalence values
# Iterate through all groups 
for ( i in 1:nlevels(independent_variable)) {
  for ( j in 1:length(prevalence_list)) {
    
    # Assign the prevalence value of a group to each sample 
    if ( as.character(independent_variable[j]) == names(total[i])){
      prevalence_list[j] <- as.numeric(total[i])
    }
  }
}

# Create an empty dataframe for Friedman Test 
df <- data.frame(name = character(0),pvalue = numeric(0),sign = character(0))

# Create an empty dataframe for Fisher's Exact Test
Fdf <- data.frame(name = character(0),pvalue = numeric(0),sign = character(0))

# Create an empty dataframe for Wilcoxon Signed Rank for matched pairs
all_pair_pval_table <- data.frame(measure = character(0),pair = character(0),Group1 = character(0),Group2 = character(0),pvalue = numeric(0),corrected = numeric(0))

# Create an empty dataframe to the results of the paired Fisher's Exact Test
all_pair_fpval_table <- data.frame(measure = character(0),pair = character(0),Group1 = character(0),Group2 = character(0),pvalue = numeric(0),corrected = numeric(0))


###################              Create empty lists to store information about signficant differences              ###################

# Making an object for lists of boxplot
list_box <- list()

# Making an object for lists of point boxplot
list_point <- list()

# Making an object for lists of violin boxplot
list_violin <- list()

# Making a list for text table for pairwise tests
texttable <- list()

# Making a list for pairwise p-value table of Wilcoxon test
pvaltable <- list()

# Making a list for pairwise p-value table of Fisher's test
fpvaltable <- list() #

# Making a list for overall p-value table for Fisher's test
allfpvaltable <- list()

# Making a list for overall p-value table for Friedman test
pvaltableAll <- list()

#######################               Friedman Rank Sum Test for each OTU for all Timepoints                     #######################
#######################                   Skillings Mack Test for Missing Data                                   #######################
fail <- FALSE

# Start calculation with the dependant variable (e.g. Richness)
for (i in dependant_variables_start:dim(input_table)[2])
{
  
  # Take the values for all samples of the dependant variable/OTU
  my_test_vector <- input_table[,i]
  
  # Save the name of the observed variable/OTU
  my_name <- colnames(input_table)[i]
  test_table <- xtabs(my_test_vector ~ independent_variable)
  
  # Number of groups to be compared
  num_of_represented_groups <- sum(as.vector(test_table) > 0)
  
  # Test whether any group is missing
  num_of_missing_groups <- nlevels(independent_variable) - num_of_represented_groups
  
  # Function to return "TRUE" or "FALSE" corresponding to "not missing" and "missing"
  if (num_of_missing_groups > 0) {
    isgroupmissing <- TRUE
  } else {
    isgroupmissing <- FALSE
  }
  
  # Empty dataframe with information for the analysis of repeated measurements
  friedman_df <- data.frame(value=double(), time=factor(),block=factor())
  
  # Save ID related values and time points in a dataframe
  tmp <- as.data.frame(cbind(my_test_vector,independent_variable,id_variable))
  
  # Create ordered dataframe for statistical analysis
  for(i in 1:nlevels(independent_variable)) {
    friedman_tmp <- subset(tmp,tmp[,2]==i)[order(subset(tmp,tmp[,2]==i)$id_variable),]
    friedman_df <- rbind(friedman_df,friedman_tmp)
  }
  
  # Save as matrix
  mat <- matrix(friedman_df[,1],nrow=nlevels(id_variable),ncol=nlevels(independent_variable))
  
  # Remove lines where no information is available for all time points
  mat <- mat[rowSums(is.na(mat)) !=  nlevels(independent_variable), ]
  
  if (ReplaceMissingValues == "NO"){
    # Remove lines with missing values completely
    mat <- mat[rowSums(is.na(mat))==0,]
    # Perfroms Firedman Test if more than one samples remain after removing missing values
    fit <- tryCatch (friedman.test(mat),error = function(i) {fail <<- TRUE})
  } else{
    # Performs a Friedman Rank Sum Test with Skillingsmack Test for missing Data
    fit <-  tryCatch (mu.friedman.test(mat,factor(as.vector(col(mat))),factor(as.vector(row(mat))),blkwght="skillingsmack"),error = function(i) {fail <<- TRUE})
    
  }
  # Function to assign corrected and not-corrected pvalues  
  if (fail) {
    my_pvalue <- NaN
    fail <- FALSE
  } else {
    
    # Round the p-value down to four decimals 
    my_pvalue <- round(fit$p.value,4)
  }
  
  # Add the p-values to the table
  newRow <- data.frame(name = my_name,pvalue = my_pvalue,missing = isgroupmissing)
  df <- rbind(df,newRow)
}

# Applying Benjamini-Hochberg (1995) correction 
df$corrected <- round(p.adjust(df$pvalue, method = "BH"),4)


#######################   wilcoxon Signed Rank Test, (paired) Fisher's Exact Test    ########

# Friedman test for analysis of variances 
# Paired Wilcoxon signed-rank test for matched pairwise comparisons
count <- 1 
x <- 0 

# Vector with all possible group combinations
idx <- combn(nlevels(independent_variable), 2)

for (i in dependant_variables_start:dim(input_table)[2])
{
  flag=TRUE
  
  # The vector of a dependant variable/OTU
  my_test_vector <- input_table[,i]
  
  # The name in the header of the dependant variable/OTU
  my_name <- colnames(input_table)[i]
  
  # Save the p-value 
  pvalue <- df[count,2]
  
  # Save information about missing group
  missing_group <- df[count,3]
  
  # Save the corrected p-value
  cpvalue <- df[count,4]
  count <- count + 1
  signif_pairs = data.frame( measure = as.character(),name = as.character(),Group1 = as.character(),Group2 = as.character(),pvalue = as.numeric())
  
  # Get the names of all group combinations
  idx_name <- combn(levels(independent_variable), 2)
  
  # If a pvalue is calculated out of the Friedman Test, the pairwise Wilcox Signed Rank Test will be computed as well 
  if (!is.na(pvalue)){
    if (pvalue <= sig.cutoff){
      # Compute p-values from Wilcoxon test for all comparisons
      ppval_res <- numeric(ncol(idx))
      
      # Create an empty dataframe to hold the results of pairwise comparison 
      pair_pval_table <-data.frame(measure = character(0),pair = character(0),Group1 = character(0),Group2 = character(0),pvalue = numeric(0),corrected = numeric(0))
      pair_pval_table <- rbind(pair_pval_table,data.frame( measure = my_name,name = "All",Group1 = " -",Group2 = "- ",pvalue = pvalue, corrected = cpvalue))
      # Compute p-values of Wilcoxon test for all comparisons
      for (i in 1:ncol(idx)){
        # Performs a Wilcoxon signed Rank Test for matched pairs
        fit <- tryCatch (wilcox.test(my_test_vector[as.numeric(independent_variable) == idx[1,i]],my_test_vector[as.numeric(independent_variable) == idx[2,i]],paired=TRUE),error = function(i) {fail <<- TRUE})
        # Function to assign corrected and not-corrected pvalues  
        if (fail) {
          ppval_res[i] <- NaN
          #my_corrected_pvalue <- 0
          fail <- FALSE
        } else {
          # Round the p-value down to four decimals 
          ppval_res[i] <- round(fit$p.value,4)
        }
        
        # Set the values of the pair and the corresponding p-value
        pair_name <- paste (idx_name[1,i],"-", idx_name[2,i],  sep = "")
        pair_num <- paste (idx[1,i],"-", idx[2,i],  sep = "")
        ppval <- round(ppval_res[i],4)
        
        # Create and add a new column to the plot table and the overall pairwise comparison table
        newRow <- data.frame( measure = my_name,name = pair_num,Group1 = idx_name[1,i],Group2 = idx_name[2,i],pvalue = ppval, corrected=0)
        pair_pval_table <- rbind(pair_pval_table,newRow)
      } 
      
      # Add the corrected p-values column to the dataframe
      pair_pval_table$corrected[-1] <- round(p.adjust(pair_pval_table$pvalue[-1], method = "BH"),4)
      Pforplot_table <- pair_pval_table[,c(-3,-4)]
      
      # Add the table with the corrected p-values to the complete list of pairwise p-values for all tests
      all_pair_pval_table <- rbind(all_pair_pval_table,pair_pval_table) 
      
      # Determine which groups are significantly different based on the results of the Wilcoxon test
      signif_pairs <- Pforplot_table[(Pforplot_table$pvalue < sig.cutoff) & !(is.na(Pforplot_table$pvalue)),]
    } 
  }
  
  # If zeros are replaced by missing values, the prevalence and the points to be plotted are the same (number of samples with a value >0)
  # If zeros are not replaced and considered as true values, the prevalence is as above, but zeros are going to be plotted in the graphs
  if (ReplaceZero == "YES") {
    plot_df <- cbind.data.frame(abundance = my_test_vector,variable = independent_variable)
    plot_df$samplekaname <- row.names(input_table)
    plot_df_prevalence <- plot_df
  }else {
    plot_df<- cbind.data.frame(abundance = my_test_vector,variable = independent_variable)
    plot_df$samplekaname <- row.names(input_table)
    my_test_vector <- fill_zero.NA(my_test_vector,ReplaceZero = "YES")
    plot_df_prevalence <- cbind.data.frame(abundance = my_test_vector,variable = independent_variable)
    plot_df_prevalence$samplekaname <- row.names(input_table)
  }
  
  
  # Calculate prevalence by counting presence or absence of the given variable in each group
  prevalence <- table(plot_df_prevalence[!is.na(plot_df_prevalence[,1]),2])
  
  # Count how many samples are absent from total number of counts
  not_found <- total - prevalence 
  pre_table <- cbind(prevalence,not_found,total)
  
  # Calculate a two-sided Fisher's test 
  Fishtest <- fisher.test(pre_table[,-3],alternative = "two.sided")
  
  # Save the p-value of the Fisher's test
  fish_pvalue <- round(Fishtest$p.value,4)
  FnewRow <- data.frame(name = my_name,pvalue = fish_pvalue)
  Fdf <- rbind(Fdf,FnewRow)
  fppval_res <- numeric(ncol(idx))
  
  # Create an empty dataframe to hold the results of pairwise comparison for pairwise Fisher's Test
  pair_fpval_table <- data.frame(measure = character(0),name = character(0),Group1 = character(0),Group2 = character(0),pvalue = numeric(0),corrected = numeric(0))
  
  # Compute p-values from Friedman test for all comparisons
  for (i in 1:ncol(idx))
  {
    pret <- as.data.frame(pre_table)
    pretrowbind <-rbind(pret[idx_name[1,i],-3],pret[idx_name[2,i],-3])
    
    # Compute two-sided Fisher's test
    fppval_res[i] <- fisher.test(pretrowbind,alternative = "two.sided")$p.value
    
    # Set values of the pair and corresponding p-value
    # Take variable name as "A-B"
    pair_name <- paste (idx_name[1,i],"-", idx_name[2,i],  sep = "")
    
    # Take variable name as "1-2"
    pair_num <- paste (idx[1,i],"-", idx[2,i],  sep = "")
    
    # Round the p-value to four decimals
    fppval <- round(fppval_res[i],4)
    
    # Create and add a new line to the plot table and the overall pairwise comparison table
    newRow <- data.frame(measure = my_name,name = pair_num,Group1 = idx_name[1,i],Group2 = idx_name[2,i],pvalue = fppval)
    pair_fpval_table <- rbind(pair_fpval_table,newRow)
  } 
  
  # Applying Benjamini-Hochberg (1995) correction 
  # Add a column with the corrected p-values 
  pair_fpval_table$corrected <- round(p.adjust(pair_fpval_table$pvalue, method = "BH"),4)
  
  # Add the table with corrected p-values to the complete list of pairwise p-values for all tests
  all_pair_fpval_table <- rbind(all_pair_fpval_table,pair_fpval_table) 
  
  # Make an object of "measure", "name", "p-value", "corrected" to print in PDF
  Fforplot_table <- pair_fpval_table[,c(-3,-4)]
  
  # Test whether the test is significant or not
  # If significant, then get value in "signif_fpairs"
  signif_fpairs <-Fforplot_table[(Fforplot_table$pvalue <= sig.cutoff) & !(is.na(Fforplot_table$pvalue)),]
  
  
  # Check if at least one of the tests (Friedman or Fisher) is signficant 
  # If at least one of them is signficant a plot will be generated
  if (fish_pvalue <= sig.cutoff || (pvalue <= sig.cutoff& !is.na(pvalue))) {
    # Generate label for the X-axis
    labelsx <- as.data.frame(table(plot_df[!is.na(plot_df_prevalence[,1]),2]))
    labeling <- paste(labelsx$Var1,"(",labelsx$Freq,"/",total,")",sep="")
    plot_df$xlabeltext <- factor(paste(plot_df$variable,"(",labelsx[match(plot_df$variable,labelsx$Var1),"Freq"],"/",prevalence_list,")",sep = ""),level=labeling)
    x = x + 1
    
    # Determine label of the y-axis
    if ((dependant_variables_start+(count-2)) < taxonomic_variables_start) {
      labelsy <- my_name
    } else{
      labelsy <- "Relative abundance (%)"
    }
    # Create a ggplot object of the plotted layout (including axis labels and scaling)
    g <-ggplot(plot_df,aes(x = xlabeltext,y = abundance))
    # Generate plot dependent on given PlotOption
    if (PlotOption == 1) {
      my_boxplot <- g + stat_boxplot(geom = "errorbar", width = 0.25) + geom_boxplot(varwidth = FALSE,width = 0.7)
      my_violinplot <- g + geom_violin(width = 0.7) + geom_boxplot(width = 0.1)
      my_point_boxplot <- g + geom_dotplot(binaxis = 'y', stackdir = 'center', dotsize = 0.7)
    } else if (PlotOption == 2) {
      my_boxplot <- g + stat_boxplot(geom = "errorbar", width = 0.25) + geom_boxplot(varwidth = FALSE,width = 0.7) + geom_dotplot(binaxis = 'y', stackdir = 'center', dotsize = 0.7)
      my_violinplot <- g + geom_violin(width = 0.7) + geom_boxplot(width = 0.1) + geom_dotplot(binaxis = 'y', stackdir = 'center', dotsize = 0.5)
      my_point_boxplot <-g + geom_dotplot(binaxis = 'y', stackdir = 'center', dotsize = 0.5)
    }else if (PlotOption == 3) {
      my_boxplot <- g + stat_boxplot(geom = "errorbar", width = 0.25) + geom_boxplot(varwidth = FALSE,width = 0.7) + 
        geom_dotplot(binaxis = 'y', stackdir = 'center', dotsize = 0.7) + 
        geom_label_repel(aes(xlabeltext, abundance, fill = NULL, label = samplekaname),fontface = 'bold', color = 'black',box.padding = unit(0.25, "lines"),point.padding = unit(0.5, "lines"),size = 2)
      my_violinplot <-g + geom_violin(width = 0.7) + geom_boxplot(width = 0.1) + 
        geom_dotplot(binaxis = 'y', stackdir = 'center', dotsize = 0.7) + geom_label_repel(aes(xlabeltext, abundance, fill = NULL, label = samplekaname),
                                                                                           fontface = 'bold', color = 'black',box.padding = unit(0.25, "lines"),
                                                                                           point.padding = unit(0.5, "lines"),size = 2)
      my_point_boxplot <-g + geom_dotplot(binaxis = 'y', stackdir = 'center', dotsize = 0.7) + geom_label_repel(aes(xlabeltext, abundance, fill = NULL, label = samplekaname),
                                                                                                                fontface = 'bold', color = 'black',box.padding = unit(0.25, "lines"),point.padding = unit(0.5, "lines"), size = 2)
    }
    
    my_boxplot <-my_boxplot + ggtitle(my_name) + guides(fill = FALSE) + ylab(labelsy) + xlab("") + theme_bw() + theme(axis.text.x = element_text(colour = "grey20",size = 12,angle = 45,hjust = 1,vjust = 1,face = "plain"),
                                                                                                                      axis.text.y = element_text(colour = "grey20",size = 12,angle = 0,hjust = 1,vjust = 0,face = "plain"),axis.title.y = element_text(colour = "grey20",size = 14,angle = 90,hjust = .5,vjust = .5,face = "plain"),
                                                                                                                      plot.title = element_text(colour = "grey22",size = 18,hjust = .5,vjust = .5,face = "bold")) + theme(plot.margin=unit(c(1,1,1.5,1.2),"cm"))
    
    my_violinplot <-my_violinplot + ggtitle(my_name) + ylab(labelsy) + guides(fill = FALSE) + xlab("") + theme_bw() +theme(axis.text.x = element_text(colour = "grey20",size = 12,angle = 45,hjust = 1,vjust = 1,face = "plain"),
                                                                                                                           axis.text.y = element_text(colour = "grey20",size = 12,angle = 0,hjust = 1,vjust = 0,face = "plain"),axis.title.y = element_text(colour = "grey20",size = 14,angle = 90,hjust = .5,vjust = .5,face = "plain"),
                                                                                                                           plot.title = element_text(colour = "grey22",size = 18,hjust = .5,vjust = .5,face = "bold")) + theme(plot.margin=unit(c(1,1,1.5,1.2),"cm"))
    
    my_point_boxplot <- my_point_boxplot + ggtitle(my_name) + theme_bw() + ylab(labelsy) +stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,geom = "crossbar", width = 0.5) +
      guides(fill = FALSE) + xlab("") + theme(legend.position = "none") + guides(colour = FALSE) + theme( axis.text.x = element_text(colour = "grey20",size = 12,angle = 45,hjust = 1,vjust =1,face = "plain"),
                                                                                                          axis.text.y = element_text(colour = "grey20",size = 12,angle = 0,hjust = 1,vjust = 0,face = "plain"),axis.title.y = element_text(colour = "grey20",size = 14,angle = 90,hjust = .5,vjust = .5,face = "plain"),
                                                                                                          plot.title = element_text(colour = "grey22",size = 18,hjust = .5,vjust = .5,face = "bold")) + theme(plot.margin=unit(c(1,1,1.5,1.2),"cm"))
    
    # Save the boxplot object in the list
    list_box[[x]] <- list()
    list_box[[x]] <- my_boxplot
    
    # Save the boxplot with points object in the list
    list_point[[x]] <- list()
    list_point[[x]] <- my_point_boxplot
    
    # Save the violin object in the list
    list_violin[[x]] <- list()
    list_violin[[x]] <- my_violinplot
    
    
    
    # Make a list object to store all "prevalence table" to print in PDF
    texttable[[x]] <- list()
    
    # Creat a gtable containing text grobs representing a character matrix
    # "mytheme" is a text theme defined at the begining
    texttable[[x]] <- tableGrob(pre_table,theme = mytheme)
    
    # Define the title of the tables
    title <- textGrob("Prevalence table",gp = gpar(fontsize = 7))
    padding <- unit(3,"mm")
    texttable[[x]] <- gtable_add_rows(texttable[[x]], heights = grobHeight(title) + padding, pos = 0)
    texttable[[x]] <- gtable_add_grob(texttable[[x]], title, 1, 1, 1, ncol(texttable[[x]]))
    
    
    # Test for the case that there are no significant pairs
    # Check whether Fisher test is significant or not
    if (fish_pvalue <= sig.cutoff) {
      if (!is.na(signif_fpairs[1,1])) {
        signif_fpairs$measure <- as.character(signif_fpairs$measure)
        signif_fpairs$name <- as.character(signif_fpairs$name)
        colnames(signif_fpairs) <-c("Species","Groups","P-value","Adj. p-value")
        fpvaltable[[x]] <- list()
        
        # Pavlue table for significant pairs
        fpvaltable[[x]] <- tableGrob(signif_fpairs[2:4],rows = NULL,theme = mytheme)
        title <- textGrob("Fisher's Exact Test - pairwise",gp = gpar(fontsize = 9))
        padding <- unit(3,"mm")
        fpvaltable[[x]] <- gtable_add_rows(fpvaltable[[x]], heights = grobHeight(title) + padding,pos = 0)
        fpvaltable[[x]] <- gtable_add_grob(fpvaltable[[x]], title, 1, 1, 1, ncol(fpvaltable[[x]]))
      }else {
        FnewRow$name <- as.character(FnewRow$name)
        FnewRow$pvalue <- as.character(FnewRow$pvalue)
        FnewRow <- cbind(FnewRow$name,"-",FnewRow$pvalue,0)
        colnames(FnewRow) <-c("Species","Groups","P-value","Adj. p-value")
        allfpvaltable[[x]] <- list()
        allfpvaltable[[x]] <- tableGrob(FnewRow,rows = NULL,theme = mytheme)
        #fpvaltable[[x]] <- NULL
      }
    }
    # Check whether Friedman test is significant or not
    if (!is.na(signif_pairs[1,1])) {
      signif_pairs$measure <- as.character(signif_pairs$measure)
      signif_pairs$name <- as.character(signif_pairs$name)
      colnames(signif_pairs) <-c("Species","Groups","P-value","Adj. p-value")
      pvaltable[[x]] <- list()
      pvaltableAll[[x]] <- list()
      
      # Pvalue table for significant pairs
      signif_all <- signif_pairs[1,c(1,3,4)]
      #if(dim(signif_pairs)[1] > 1) {
      signif_pairs <- signif_pairs[2:dim(signif_pairs)[1],]
      pvaltable[[x]] <-tableGrob(signif_pairs[2:4],rows = NULL,theme = mytheme)
      
      # Title of tables in the PDF
      title <- textGrob("Paired Wilcoxon Signed Rank Sum Test",gp = gpar(fontsize = 9))
      padding <- unit(2,"mm")
      pvaltable[[x]] <- gtable_add_rows(pvaltable[[x]], heights = grobHeight(title) + padding,pos = 0)
      pvaltable[[x]] <- gtable_add_grob(pvaltable[[x]], title, 1, 1, 1, ncol(pvaltable[[x]]))
      colnames(signif_all) <-c(" ","P-value","Adj. p-value")
      pvaltableAll[[x]] <- tableGrob(signif_all,rows = NULL,theme = mytheme)
      title <- textGrob("Friedman Test - all groups ",gp = gpar(fontsize = 9))
      padding <- unit(2,"mm")
      pvaltableAll[[x]] <- gtable_add_rows(pvaltableAll[[x]], heights = grobHeight(title) + padding,pos = 0)
      pvaltableAll[[x]] <- gtable_add_grob(pvaltableAll[[x]], title, 1, 1, 1, ncol(pvaltableAll[[x]]))
    }
  }
  
}


# Apply Benjamini-Hochberg (1995) correction 
# Add a column with the corrected p-values 
Fdf$corrected <- round(p.adjust(Fdf$pvalue, method = "BH"),4)
sig_Fdf <- subset(Fdf,Fdf$pvalue<=sig.cutoff)
counter = 1

if(length(allfpvaltable)!=length(fpvaltable)) {
  if(length(allfpvaltable) > length(fpvaltable)){
    for ( i in (length(fpvaltable)+1):(length(allfpvaltable)+1)) {
      fpvaltable[[i]] <- list()
      fpvaltable[[i]] <- NULL
    }
  }
  else{
    for ( i in (length(allfpvaltable)+1):(length(fpvaltable)+1)) {
      allfpvaltable[[i]] <- list()
      allfpvaltable[[i]] <- NULL
    }
  }
}

if (length(fpvaltable)!=0){
  for (i in 1:length(fpvaltable)){
    if (!is.null(fpvaltable[[i]]) || !is.null(allfpvaltable[[i]])){
      colnames(sig_Fdf) <-c(" ","P-value","Adj.p-value")
      allfpvaltable[[i]] <- list()
      title_all <- textGrob("Fisher's Exact Test - all groups",gp = gpar(fontsize = 9))
      padding <- unit(3,"mm")
      allfpvaltable[[i]] <- tableGrob(sig_Fdf[counter,],rows = NULL,theme = mytheme)
      allfpvaltable[[i]] <- gtable_add_rows(allfpvaltable[[i]], heights = grobHeight(title_all) + padding,pos = 0)
      allfpvaltable[[i]] <- gtable_add_grob(allfpvaltable[[i]], title_all, 1, 1, 1, ncol(allfpvaltable[[i]]))
      counter=counter+1
    }
  }
}

# If the last pvalues are only signficant for fisher OR Wilcox additional empty lists has to be added to the array of lists
if (length(pvaltableAll) < length(allfpvaltable)) {
  # Add empty list entries in the Wilcox and Kruskal Walis tables
  for ( i in (length(pvaltableAll)+1):(length(allfpvaltable)+1)) {
    pvaltable[[i]] <- list()
    pvaltable[[i]] <- NULL
    pvaltableAll[[i]] <- list()
    pvaltableAll[[i]] <- NULL
  }
} 

if (length(pvaltableAll) > length(allfpvaltable)) {
  # Add empty list entries in the Fisher tables
  for ( i in (length(allfpvaltable)+1):(length(pvaltableAll)+1)) {
    fpvaltable[[i]] <- list()
    fpvaltable[[i]] <- NULL
    allfpvaltable[[i]] <- list()
    allfpvaltable[[i]] <- NULL
  }
}

####################                 Print plots in PDF               ############################

# Take current path in one variable to store results in seperate folders in further steps
OriginalPath <- getwd()

# Take the name of the independent variable to name the folder
prefix = paste(dependant_variable_name,strsplit(input_filename,"[.]")[[1]][1],sep="_")

# Make a directory name with independent variable name and date
newdir <- paste("Over-Time",prefix,Sys.Date(), sep = "_")

# Create a directory 
dir.create(newdir)

# Set path for all outputs to the new directory
setwd(newdir)
if(!dim(all_pair_pval_table)[1]==0){
  
  # Passing type of plots
  for (plotType in c("box","boxpoint","violin"))
  {
    
    # Switching to plots type
    plotb <- switch(plotType,box = list_box,boxpoint = list_point,violin = list_violin)
    
    # Open a PDF to print all outputs 
    pdf(paste("plot",plotType,".pdf"),onefile = T)
    for (pos in 1:x) {
      # No significant results for Friedman Test
      if (is.null(pvaltableAll[[pos]])) { 
        # Fisher Test is not signficant
        if (is.null(allfpvaltable[[pos]])) {
          plotb[[pos]]
        } 
        # Signfiicant Fisher Test
        else {
          # Check if paired Fisher is signficant as well
          if (is.null(fpvaltable[[pos]])) {
            # Only the overall Fisher Test is significant 
            grid.arrange(plotb[[pos]],arrangeGrob(allfpvaltable[[pos]],nrow = 1,ncol=1),nrow = 2,ncol=2,heights = c(3,1),as.table = T)
          }
          else {
            # Both Fisher Tests are significant 
            if (nlevels(independent_variable)>5){
              print(plotb[[pos]])
              print(plot_grid(allfpvaltable[[pos]],fpvaltable[[pos]],ncol=1, nrow = 2,align="v", rel_heights=c(1,10)))
            }
            else{
              grid.arrange(plotb[[pos]],arrangeGrob(allfpvaltable[[pos]],fpvaltable[[pos]],nrow = 2,ncol=1),nrow = 2,ncol=2,heights = c(3,1),as.table = T)
            }        
          }
        }
      }
      # Significant Friedman Test
      else {
        # Fisher test is not signficant
        if (is.null(allfpvaltable[[pos]])) {
          # Add table only for Friedman Test 
          if (is.null(pvaltable[[pos]])) {
            grid.arrange(plotb[[pos]],arrangeGrob(pvaltableAll[[pos]],nrow = 1,ncol=1),nrow = 2,ncol=2,heights = c(3,1),as.table = T)
          }
          # Add table for Friedman and Wilcoxon test
          else{
            if (nlevels(independent_variable)>5){
              print(plotb[[pos]])
              print(plot_grid(pvaltableAll[[pos]],pvaltable[[pos]],ncol=1, nrow = 2,align="v", rel_heights=c(1,10)))
            }
            else{
              grid.arrange(plotb[[pos]],arrangeGrob(pvaltableAll[[pos]], pvaltable[[pos]],nrow = 2,ncol=1),nrow = 2,ncol=2,heights = c(3,1),as.table = T)
            }
          }
        } 
        # Significant Friedman and Fisher Test
        else {
          # The paired Fisher test is not significant 
          if (is.null(fpvaltable[[pos]])){
            if (nlevels(independent_variable)>5) {
              print(plotb[[pos]])
              print(plot_grid(allfpvaltable[[pos]],pvaltableAll[[pos]],pvaltable[[pos]],ncol=2,nrow = 2,align="v", rel_heights=c(1,10)))
            }else{
              # Add table for both tests
              grid.arrange(plotb[[pos]],arrangeGrob(pvaltableAll[[pos]], pvaltable[[pos]],allfpvaltable[[pos]],nrow = 4,ncol=1),nrow = 2,ncol=2,heights = c(3,1),as.table = T)
            }  
          }
          else {
            # The paired Fisher Test is significant
            if (nlevels(independent_variable)>5) {
              print(plotb[[pos]])
              print(plot_grid(allfpvaltable[[pos]],pvaltableAll[[pos]],fpvaltable[[pos]],pvaltable[[pos]],ncol=2,nrow = 2,align="v", rel_heights=c(1,10)))
            }else{
              # Add table for both tests
              grid.arrange(plotb[[pos]],arrangeGrob(pvaltableAll[[pos]],pvaltable[[pos]],allfpvaltable[[pos]],fpvaltable[[pos]],nrow = 4,ncol=1),nrow = 2,ncol=2,heights = c(3,1),as.table = T)
            }   
          }
        }
      }
    }
    dev.off()
  }
}
################################################################################
######                        Write Output Files in Seperate folder       ######
#################################################################################


# Main file generated after all pre-processing and used for statistical analysis
# Serial-Group-Comparisons input Table
write.table(input_table, paste(strsplit(input_filename,"[.]")[[1]][1],"-",dependant_variable_name,"-modified.txt", sep = ""), sep = "\t", col.names = NA, quote = FALSE)

# Table with the results of Friedman test 
write.table(df[,c(1,2,4)], paste(strsplit(input_filename,"[.]")[[1]][1],"-",dependant_variable_name,"-pvalues.tab", sep = ""), sep = "\t", col.names = NA, quote = FALSE)

# Table with the results of Wilcoxon Signed Rank Sum Test
write.table(all_pair_pval_table[,-2], paste(strsplit(input_filename,"[.]")[[1]][1],"-",dependant_variable_name,"-sign_pairs.tab", sep = ""), sep = "\t", col.names = NA, quote = FALSE)

# Table with the results of Fisher's Exact Test
write.table(Fdf, paste(strsplit(input_filename,"[.]")[[1]][1],"-",dependant_variable_name,"-FisherTestAll.tab", sep = ""), sep = "\t", col.names = NA, quote = FALSE)

# Table with the results of pairwise Fisher's Exact Test
write.table(all_pair_fpval_table[,-2], paste(strsplit(input_filename,"[.]")[[1]][1],"-",dependant_variable_name,"-FisherTestPairWise.tab", sep = ""), sep = "\t", col.names = NA, quote = FALSE)

# Input file for correlation script (6.Correlation)
Corr_input_table <- input_table[,-c(1:(dependant_variables_start-1))]
suppressWarnings (try(write.table(Corr_input_table, paste("../../6.Correlations/",strsplit(input_filename,"[.]")[[1]][1],"_","Corr_input_table.tab",sep=""), sep ="\t",col.names = NA, quote = FALSE), silent =TRUE))

# Adding log file in analysis
sink(file = "my_analysis_log.txt")
cat ("***************************************","\n")
cat ("Parameters Used for Analysis","\n")
cat ("***************************************","\n","\n")
cat ("dependant_variable_name:",dependant_variable_name,"\n","\n")
cat ("dependant_variables_start:",dependant_variables_start,"\n","\n")
cat ("taxonomic_variables_start:",taxonomic_variables_start,"\n","\n")
cat ("abundance_cutoff:", abundance_cutoff,"\n","\n")
cat ("prevalence_cutoff:",prevalence_cutoff,"\n","\n")
cat ("max_median_cutoff:",max_median_cutoff,"\n","\n")
cat ("PlotOption:",PlotOption,"\n","\n")
cat ("ReplaceZero:",ReplaceZero,"\n","\n")
sink()
setwd(OriginalPath)

if(!flag) { stop("
                 It was not possible to install all required R libraries properly.
                 Please check the installation of all required libraries manually.\n
                 Required libaries:ade4, GUniFrac, phangorn, randomcoloR, Rcpp")
}

########################################################
##    Script Ended !!!!
#########################################################
